<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>World Creator — Browser</title>
  <style>
    :root {
      --sidebar-w: 155px;
      --right-w: 380px;
      --top-h: 48px
    }

    html, body {
      height: 100%;
      margin: 0;
      font-family: system-ui, Segoe UI, Roboto, Arial;
      background: #efefef
    }

    #app {
      display: flex;
      flex-direction: column;
      height: 100vh
    }

    .topbar {
      height: var(--top-h);
      display: flex;
      align-items: center;
      padding: 6px 10px;
      gap: 8px;
      background: #f7f7f7;
      border-bottom: 1px solid #ddd
    }

    .topbar input[type=text] {
      flex: 1;
      padding: 6px;
      border: 1px solid #ccc;
      border-radius: 4px
    }

    .topbar button {
      padding: 6px 10px
    }

    .main {
      display: flex;
      flex: 1;
      overflow: hidden
    }

    .tools {
      width: var(--sidebar-w);
      background: #fafafa;
      border-right: 1px solid #ddd;
      padding: 8px;
      box-sizing: border-box
    }

    .canvas-area {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      position: relative;
      background: #e9e9e9
    }

    .rightpanel {
      width: var(--right-w);
      background: #fafafa;
      border-left: 1px solid #ddd;
      padding: 8px;
      box-sizing: border-box;
      overflow: auto
    }

    .canvas-wrap {
      background: white;
      box-shadow: 0 1px 6px rgba(0, 0, 0, 0.08);
      overflow: hidden
    }

    canvas.canvas {
      background: transparent;
      display: block
    }

    .tools button {
      display: block;
      margin: 6px 0;
      padding: 8px;
      text-align: center;
      width: 100%
    }

    .block-selector {
      height: 110px;
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 8px;
      border-top: 1px solid #ddd;
      overflow: auto
    }

    .block-item {
      width: 72px;
      height: 72px;
      border: 1px solid #aaa;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer
    }

    .layer {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 6px;
      border: 1px solid #ddd;
      margin-bottom: 6px;
      background: white
    }

    .layer .title {
      flex: 1
    }

    .layer.hidden {
      opacity: 0.45
    }

    .small {
      font-size: 12px
    }

    .hidden {
      display: none
    }

    .file-input {
      display: none
    }

    button {
      background-color: #4CAF50;   /* green */
      color: white;
      font-size: 14px;
      padding: 4px 8px;
      border: none;
      border-radius: 4px;          /* subtle rounding */
      cursor: pointer;
      transition: background-color 0.2s ease;
    }

    button:hover {
      background-color: #45a049;   /* slightly lighter on hover */
    }


  </style>
</head>
<body>
<div id="app">
  <div class="topbar">
    <input id="title" type="text" placeholder="Level title...">
    <button id="save">Save</button>
    <button id="importProject">Import</button>
    <button id="importScheme">Import Block Scheme</button>
    <input id="fileSchemeJson" class="file-input" type="file" accept="application/json">
    <input id="fileSchemeImages" class="file-input" type="file" accept="image/*" multiple>
    <input id="fileOpenProject" class="file-input" type="file" accept=".wproj,application/json">
    <div id="fileInfo" class="small"></div>
  </div>
  <div class="main">
    <div class="tools">
      <div><strong>Tools</strong></div>
      <button data-tool="filled-rect">Filled rectangle</button>
      <button data-tool="unfilled-rect">Unfilled rectangle</button>
      <button data-tool="freehand">Freehand</button>
      <button data-tool="line">Line</button>
      <button data-tool="lasso">Filled lasso</button>
      <hr>
      <div><strong>Actions</strong></div>
      <button id="undo" disabled>Undo</button>
      <button id="redo" disabled>Redo</button>
    </div>

    <div class="canvas-area" style="overflow:hidden;">
      <div id="canvasWrap" class="canvas-wrap">
        <canvas id="editor" class="canvas" width="1280" height="800"></canvas>
      </div>
      <div class="block-selector" id="blockSelector"></div>
    </div>

    <div class="rightpanel">
      <div style="display:flex;justify-content:space-between;align-items:center"><strong>Layers</strong><!--button id="addLayer">+</button--></div>
      <div id="layersList"></div>
      <div style="margin-top:8px">
        <button id="exportLayer">Export Layer</button>
        <!--button id="importLayer">Import Layer</button-->
        <input id="fileImportLayer" class="file-input" type="file" accept="application/json">
      </div>
      <div id="infoText" class="small" style="margin-top:12px;color:#555">
        <p>Use mouse wheel to zoom in/out.</p>
        <p>Click and drag with middle mouse button to pan.</p>
        <p>Right-click or hold Ctrl while drawing to erase blocks.</p>
      </div>
      <div id="positionInfo" class="small" style="position:absolute;bottom:12px;color:#555">
        <p id="blockPos">Block: (0, 0)</p>
        <p id="chunkPos">Chunk: (0, 0)</p>
        <p id="sizeInfo">Size: 0 x 0 blocks</p>
      </div>
    </div>
  </div>
</div>

<script>
  const BLOCK_SIZE = 64;
  const CHUNK_SIZE = 64;
  let scale = 1.0;
  let offsetX = 0, offsetY = 0;
  let currentTool = 'freehand';
  let currentBlock = {id: 1, name: 'Block', color: '#888'};
  let layers = [];
  let activeLayer = 0;
  let filename = null;
  let blockScheme = {};

  fetch('./blockScheme.json')
          .then(response => response.json())   // parse JSON
          .then(json => {
            for (const [key, val] of Object.entries(json)) {
              if (val && typeof val === 'string' && val.startsWith('data:')) {
                blockScheme[key] = {id: key, name: key, url: val};
              } else if (val && typeof val === 'string' && map[val]) {
                blockScheme[key] = {id: key, name: key, url: map[val]};
              } else {
                blockScheme[key] = {id: key, name: key, url: null};
              }
            }
            buildBlockSelector()
            console.log(blockScheme);
          })
          .catch(err => console.error('Error loading JSON:', err));

  let undoStack = [], redoStack = [];
  const canvas = document.getElementById('editor');
  const ctx = canvas.getContext('2d');
  canvas.style.cursor = 'crosshair';

  function createDefaultProject() {
    layers = [{name: 'backdrop', opacity: 1, data: {}}, {name: 'back', opacity: 1, data: {}}, {name: 'front', opacity: 1, data: {}}];
    activeLayer = 2;
    document.getElementById('title').value = 'Untitled';
    buildLayersUI();
    buildBlockSelector();
    draw();
  }

  function buildBlockSelector() {
    const sel = document.getElementById('blockSelector');
    sel.innerHTML = '';
    const blocks = Object.values(blockScheme).length ? Object.values(blockScheme) : [currentBlock];
    firstB = null
    blocks.forEach(b => {
      const d = document.createElement('div');
      d.className = 'block-item';
      d.title = b.name;
      d.dataset.block = JSON.stringify(b);
      if (b.url) {
        d.innerHTML = `<img src="${b.url}" style="width:64px; height:64px; image-rendering: pixelated; image-rendering: -moz-crisp-edges; image-rendering: crisp-edges;">`;
      } else {
        d.innerHTML = `<div style="width:56px;height:56px;background:${b.color || '#888'};border-radius:4px"></div>`;
      }
      d.onclick = () => {
        currentBlock = b;
        highlightSelectedBlock();
      };
      sel.appendChild(d);
      if (firstB === null) firstB = b;
    });
    if (firstB !== null) currentBlock = firstB;
    highlightSelectedBlock();
  }

  function highlightSelectedBlock() {
    document.querySelectorAll('.block-item').forEach(el => {
      try {
        const b = JSON.parse(el.dataset.block);
        el.style.outline = (b.id === currentBlock.id) ? '3px solid #0078d4' : '1px solid #aaa';
      } catch (e) {}
    });
  }

  function buildLayersUI() {
    const list = document.getElementById('layersList');
    list.innerHTML = '';
    layers.forEach((L, i) => {
      const div = document.createElement('div');
      div.className = 'layer';
      div.innerHTML = `<div class="title">${L.name}</div>`;
      const sel = document.createElement('button');
      sel.textContent = (i === activeLayer) ? 'Active' : 'Select';
      sel.onclick = () => {
        activeLayer = i;
        buildLayersUI();
        draw();
      };
      const up = document.createElement('button');
      up.textContent = '▲';
      up.onclick = () => {
        if (i > 0) {
          layers.splice(i - 1, 0, layers.splice(i, 1)[0]);
          buildLayersUI();
          draw();
        }
      };
      const down = document.createElement('button');
      down.textContent = '▼';
      down.onclick = () => {
        if (i < layers.length - 1) {
          layers.splice(i + 1, 0, layers.splice(i, 1)[0]);
          buildLayersUI();
          draw();
        }
      };
      const opacity = document.createElement('input');
      opacity.type = 'range';
      opacity.min = 0;
      opacity.max = 1;
      opacity.step = 0.05;
      opacity.value = L.opacity || 1;
      opacity.oninput = () => {
        L.opacity = parseFloat(opacity.value);
        draw();
      };
      div.appendChild(sel);
      div.appendChild(up);
      div.appendChild(down);
      div.appendChild(opacity);
      list.appendChild(div);
    });
  }

  const imageCache = new Map(); // key: url, value: HTMLImageElement


  function getCachedImage(url) {
    if (!imageCache.has(url)) {
      const img = new Image();
      img.src = url;
      imageCache.set(url, img);
    }
    return imageCache.get(url);
  }


  function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.save();
    ctx.imageSmoothingEnabled = false;
    ctx.translate(offsetX, offsetY);
    ctx.scale(scale, scale);
    for (let li = 0; li < layers.length; li++) {
      const L = layers[li];
      ctx.globalAlpha = (li === activeLayer) ? 1.0 : (L.opacity || 0.5);
      Object.entries(L.data).forEach(([key, bid]) => {
        const [x, y] = key.split(',').map(Number);

        // Calculate world-space bounds
        const blockLeft = x * BLOCK_SIZE;
        const blockTop = y * BLOCK_SIZE;
        const blockRight = blockLeft + BLOCK_SIZE;
        const blockBottom = blockTop + BLOCK_SIZE;

        // Calculate visible world-space viewport
        const viewLeft = -offsetX / scale;
        const viewTop = -offsetY / scale;
        const viewRight = viewLeft + canvas.width / scale;
        const viewBottom = viewTop + canvas.height / scale;

        // Skip if block is completely outside viewport
        if (blockRight < viewLeft || blockLeft > viewRight ||
                blockBottom < viewTop || blockTop > viewBottom) {
          return;
        }

        const b = blockScheme[bid] || {id: bid, color: null};
        if (b && b.url) {
          const img = getCachedImage(b.url);
          if (img.complete) {
            ctx.drawImage(img, blockLeft, blockTop, BLOCK_SIZE, BLOCK_SIZE);
          }
        } else {
          ctx.fillStyle = b.color || blockColor(bid || 0);
          ctx.fillRect(blockLeft, blockTop, BLOCK_SIZE, BLOCK_SIZE);
        }
      });
    }
    ctx.globalAlpha = 1.0;
    const left = -offsetX / scale;
    const top = -offsetY / scale;
    const right = left + canvas.width / scale;
    const bottom = top + canvas.height / scale;
    const startX = Math.floor(left / BLOCK_SIZE) - 1;
    const endX = Math.ceil(right / BLOCK_SIZE) + 1;
    const startY = Math.floor(top / BLOCK_SIZE) - 1;
    const endY = Math.ceil(bottom / BLOCK_SIZE) + 1;
    ctx.lineWidth = 1 / scale;
    ctx.strokeStyle = 'rgba(120,120,120,0.35)';
    ctx.beginPath();
    for (let x = startX; x <= endX; x++) {
      ctx.moveTo(x * BLOCK_SIZE, startY * BLOCK_SIZE);
      ctx.lineTo(x * BLOCK_SIZE, endY * BLOCK_SIZE);
    }
    for (let y = startY; y <= endY; y++) {
      ctx.moveTo(startX * BLOCK_SIZE, y * BLOCK_SIZE);
      ctx.lineTo(endX * BLOCK_SIZE, y * BLOCK_SIZE);
    }
    ctx.stroke();
    ctx.lineWidth = 2 / scale;
    ctx.strokeStyle = 'rgba(20,20,20,0.7)';
    ctx.beginPath();
    const chunkStartX = Math.floor(startX / CHUNK_SIZE) * CHUNK_SIZE;
    const chunkEndX = Math.ceil(endX / CHUNK_SIZE) * CHUNK_SIZE;
    const chunkStartY = Math.floor(startY / CHUNK_SIZE) * CHUNK_SIZE;
    const chunkEndY = Math.ceil(endY / CHUNK_SIZE) * CHUNK_SIZE;
    for (let x = chunkStartX; x <= chunkEndX; x += CHUNK_SIZE) {
      ctx.moveTo(x * BLOCK_SIZE, chunkStartY * BLOCK_SIZE);
      ctx.lineTo(x * BLOCK_SIZE, chunkEndY * BLOCK_SIZE);
    }
    for (let y = chunkStartY; y <= chunkEndY; y += CHUNK_SIZE) {
      ctx.moveTo(chunkStartX * BLOCK_SIZE, y * BLOCK_SIZE);
      ctx.lineTo(chunkEndX * BLOCK_SIZE, y * BLOCK_SIZE);
    }
    ctx.stroke();

    ctx.lineWidth = 2 / scale;
    ctx.strokeStyle = 'rgba(255,0,0,1)';
    ctx.beginPath();

    for (let x = chunkStartX; x <= chunkEndX; x += CHUNK_SIZE) {
      if (x === 0) {
        ctx.moveTo(x * BLOCK_SIZE, chunkStartY * BLOCK_SIZE);
        ctx.lineTo(x * BLOCK_SIZE, chunkEndY * BLOCK_SIZE);
      }
    }

    for (let y = chunkStartY; y <= chunkEndY; y += CHUNK_SIZE) {
      if (y === 0) {
        ctx.moveTo(chunkStartX * BLOCK_SIZE, y * BLOCK_SIZE);
        ctx.lineTo(chunkEndX * BLOCK_SIZE, y * BLOCK_SIZE);
      }
    }

    ctx.fillStyle = "rgba(0,0,0,0.7)";
    ctx.font = `${12 / scale}px sans-serif`; // auto-scale with zoom

    for (let cx = chunkStartX; cx < chunkEndX; cx += CHUNK_SIZE) {
      for (let cy = chunkStartY; cy < chunkEndY; cy += CHUNK_SIZE) {

        const chunkX = cx / CHUNK_SIZE;
        const chunkY = cy / CHUNK_SIZE;

        const worldX = cx * BLOCK_SIZE;
        const worldY = cy * BLOCK_SIZE;

        ctx.fillText(
                `(${chunkX}, ${chunkY})`,
                worldX + 4 / scale,       // small padding
                worldY + 12 / scale
        );
      }
    }

    ctx.stroke();
    ctx.restore();
  }

  function blockColor(bid) {
    const a = (bid * 9301 + 49297) % 233280;
    const r = 50 + (a % 200);
    const g = 50 + ((a >> 8) % 200);
    const b = 50 + ((a >> 16) % 200);
    return `rgb(${r},${g},${b})`;
  }

  let mouseDown = false, midDown = false, lastCell = null;
  canvas.addEventListener('wheel', e => {
    e.preventDefault();
    const rect = canvas.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;
    const oldScale = scale;
    scale *= (e.deltaY > 0) ? 0.9 : 1.1;
    scale = Math.max(0.05, Math.min(6, scale));
    offsetX -= (mx - offsetX) * (scale / oldScale - 1);
    offsetY -= (my - offsetY) * (scale / oldScale - 1);
    draw();
  });
  canvas.addEventListener('mousedown', e => {
    if (e.button === 1) {
      midDown = true;
      canvas.style.cursor = 'grabbing';
    } else {
      mouseDown = true;
      handlePointer(e);
    }
  });
  canvas.addEventListener('mouseup', e => {
    if (e.button === 1) {
      midDown = false;
      canvas.style.cursor = 'crosshair';
    }
    mouseDown = false;
    lastCell = null;
    if (activeAction) finishAction();
    activeAction = null;
  });
  canvas.addEventListener('mousemove', e => {
    document.getElementById("blockPos").innerText = `Block: (${screenToCell(e.clientX, e.clientY).join(', ')})`;
    document.getElementById("chunkPos").innerText = `Chunk: (${Math.floor(screenToCell(e.clientX, e.clientY)[0] / CHUNK_SIZE)}, ${Math.floor(screenToCell(e.clientX, e.clientY)[1] / CHUNK_SIZE)})`;

    if (midDown) {
      offsetX += e.movementX;
      offsetY += e.movementY;

      draw();
    }
    if (mouseDown) {
      handlePointer(e);
    }
    if (activeAction && activeAction.previewable && mouseDown) {
      activeAction.preview(e);
    }
  });
  canvas.addEventListener('contextmenu', e => e.preventDefault());

  function screenToCell(clientX, clientY) {
    const rect = canvas.getBoundingClientRect();
    const x = (clientX - rect.left - offsetX) / scale;
    const y = (clientY - rect.top - offsetY) / scale;
    const cx = Math.floor(x / BLOCK_SIZE);
    const cy = Math.floor(y / BLOCK_SIZE);
    return [cx, cy];
  }

  let activeAction = null;

  function startAction(type, startCell, isErase = false) {
    const L = layers[activeLayer];
    activeAction = {
      type,
      start: startCell,
      points: [startCell],
      layer: activeLayer,
      isErase,
      changes: [],
      complete: false,
      previewable: true,
      preview(e) {
        draw();
        const ctx2 = ctx;
        ctx2.save();
        ctx2.translate(offsetX, offsetY);
        ctx2.scale(scale, scale);
        ctx2.lineWidth = 1 / scale;
        ctx2.strokeStyle = 'rgba(0,0,0,0.8)';
        ctx2.fillStyle = 'rgba(0,0,0,0.15)';
        if (type === 'line' || type === 'unfilled-rect' || type === 'filled-rect') {
          const [cx, cy] = screenToCell(e.clientX, e.clientY);
          ctx2.beginPath();
          if (type === 'line') {
            ctx2.moveTo((startCell[0] + 0.5) * BLOCK_SIZE, (startCell[1] + 0.5) * BLOCK_SIZE);
            ctx2.lineTo((cx + 0.5) * BLOCK_SIZE, (cy + 0.5) * BLOCK_SIZE);
            ctx2.stroke();
            document.getElementById("sizeInfo").innerText = `Size: ${Math.abs(cx - startCell[0]) + 1} x ${Math.abs(cy - startCell[1]) + 1} blocks`;
          } else {
            const x0 = Math.min(startCell[0], cx), x1 = Math.max(startCell[0], cx);
            const y0 = Math.min(startCell[1], cy), y1 = Math.max(startCell[1], cy);
            ctx2.strokeRect(x0 * BLOCK_SIZE, y0 * BLOCK_SIZE, (x1 - x0 + 1) * BLOCK_SIZE, (y1 - y0 + 1) * BLOCK_SIZE);
            if (type === 'filled-rect') ctx2.fillRect(x0 * BLOCK_SIZE, y0 * BLOCK_SIZE, (x1 - x0 + 1) * BLOCK_SIZE, (y1 - y0 + 1) * BLOCK_SIZE);
            document.getElementById("sizeInfo").innerText = `Size: ${Math.abs(x1 - x0) + 1} x ${Math.abs(y1 - y0) + 1} blocks`;
          }
        } else if (type === 'lasso') {
          const pts = activeAction.points.slice();
          const p = screenToCell(e.clientX, e.clientY);
          pts.push(p);
          ctx2.beginPath();
          if (pts.length) {
            ctx2.moveTo((pts[0][0] + 0.5) * BLOCK_SIZE, (pts[0][1] + 0.5) * BLOCK_SIZE);
            for (let i = 1; i < pts.length; i++) ctx2.lineTo((pts[i][0] + 0.5) * BLOCK_SIZE, (pts[i][1] + 0.5) * BLOCK_SIZE);
            ctx2.closePath();
            ctx2.fill();
            ctx2.stroke();
          }
          document.getElementById("sizeInfo").innerText = `Size: ${pts.length - 1} points`;
        }
        ctx2.restore();
      }
    };
  }

  function finishAction() {
    if (!activeAction) return;
    const a = activeAction;
    const changed = [];
    if (a.type === 'freehand') {
    } else if (a.type === 'line') {
      const [x0, y0] = a.start;
      const [x1, y1] = a.points[a.points.length - 1];
      const cells = bresenham(x0, y0, x1, y1);
      cells.forEach(c => {
        const key = c[0] + ',' + c[1];
        const old = layers[a.layer].data[key] || null;
        const newv = a.isErase ? null : currentBlock.id;
        if (old !== newv) {
          changed.push({x: c[0], y: c[1], old, new: newv});
          if (newv === null) delete layers[a.layer].data[key]; else layers[a.layer].data[key] = newv;
        }
      });
    } else if (a.type === 'filled-rect' || a.type === 'unfilled-rect') {
      const [x0, y0] = a.start;
      const [x1, y1] = a.points[a.points.length - 1];
      const lx = Math.min(x0, x1), rx = Math.max(x0, x1);
      const ty = Math.min(y0, y1), by = Math.max(y0, y1);
      for (let x = lx; x <= rx; x++) {
        for (let y = ty; y <= by; y++) {
          const key = x + ',' + y;
          const old = layers[a.layer].data[key] || null;
          let isOutline = false;
          if (a.type === 'unfilled-rect') {
            if (x === lx || x === rx || y === ty || y === by) isOutline = true;
          } else isOutline = true;
          if (isOutline) {
            const newv = a.isErase ? null : currentBlock.id;
            if (old !== newv) {
              changed.push({x, y, old, new: newv});
              if (newv === null) delete layers[a.layer].data[key]; else layers[a.layer].data[key] = newv;
            }
          }
        }
      }
    } else if (a.type === 'lasso') {
      const poly = a.points.slice();
      let minx = 1e9, miny = 1e9, maxx = -1e9, maxy = -1e9;
      poly.forEach(p => {
        minx = Math.min(minx, p[0]);
        miny = Math.min(miny, p[1]);
        maxx = Math.max(maxx, p[0]);
        maxy = Math.max(maxy, p[1]);
      });
      totalBlocks = 0;
      for (let x = minx; x <= maxx; x++) {
        for (let y = miny; y <= maxy; y++) {
          if (pointInPoly([x + 0.5, y + 0.5], poly)) {
            const key = x + ',' + y;
            const old = layers[a.layer].data[key] || null;
            const newv = a.isErase ? null : currentBlock.id;
            if (old !== newv) {
              changed.push({x, y, old, new: newv});
              if (newv === null) delete layers[a.layer].data[key]; else layers[a.layer].data[key] = newv;
            }
            totalBlocks++
          }
        }
      }
      document.getElementById("sizeInfo").innerText = `Size: ${totalBlocks} blocks`;
    }
    if (changed.length) pushUndo({layerIndex: a.layer, changes: changed});
    draw();
  }

  function handlePointer(e) {
    const [cx, cy] = screenToCell(e.clientX, e.clientY);
    const isErase = (e.button === 2) || e.ctrlKey;
    if (!mouseDown) return;
    if (!activeAction) {
      startAction(currentTool, [cx, cy], isErase);
      if (currentTool === 'freehand') activeAction.changes = [];
      return;
    }

    if (activeAction && activeAction.type === 'lasso') {
      const p = screenToCell(e.clientX, e.clientY);
      const last = activeAction.points[activeAction.points.length - 1];

      // Prevent duplicates
      if (!last || last[0] !== p[0] || last[1] !== p[1]) {
        activeAction.points.push(p);
      }
    }


    if (activeAction.type === 'freehand') {
      const key = cx + ',' + cy;
      const L = layers[activeAction.layer];
      const old = L.data[key] || null;
      const newv = activeAction.isErase ? null : currentBlock.id;
      if (old !== newv) {
        activeAction.changes.push({x: cx, y: cy, old, new: newv});
        if (newv === null) delete L.data[key]; else L.data[key] = newv;
        pushUndo({layerIndex: activeAction.layer, changes: [{x: cx, y: cy, old, new: newv}]});
        draw();
      }
    } else {
      activeAction.points[activeAction.points.length - 1] = [cx, cy];
      draw();
    }
  }

  function bresenham(x0, y0, x1, y1) {
    const cells = [];
    let dx = Math.abs(x1 - x0), sx = x0 < x1 ? 1 : -1;
    let dy = -Math.abs(y1 - y0), sy = y0 < y1 ? 1 : -1;
    let err = dx + dy;
    while (true) {
      cells.push([x0, y0]);
      if (x0 === x1 && y0 === y1) break;
      let e2 = 2 * err;
      if (e2 >= dy) {
        err += dy;
        x0 += sx;
      }
      if (e2 <= dx) {
        err += dx;
        y0 += sy;
      }
    }
    return cells;
  }

  function pointInPoly(pt, poly) {
    let x = pt[0], y = pt[1], inside = false;
    for (let i = 0, j = poly.length - 1; i < poly.length; j = i++) {
      const xi = poly[i][0], yi = poly[i][1];
      const xj = poly[j][0], yj = poly[j][1];
      const intersect = ((yi > y) != (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
      if (intersect) inside = !inside;
    }
    return inside;
  }

  function pushUndo(diff) {
    undoStack.push(diff);
    redoStack.length = 0;
    document.getElementById('undo').disabled = false;
    document.getElementById('redo').disabled = true;
  }

  function doUndo() {
    if (!undoStack.length) return;
    const diff = undoStack.pop();
    applyDiff(diff, true);
    redoStack.push(diff);
    document.getElementById('redo').disabled = false;
  }

  function doRedo() {
    if (!redoStack.length) return;
    const diff = redoStack.pop();
    applyDiff(diff, false);
    undoStack.push(diff);
  }

  function applyDiff(diff, inverse = false) {
    const L = layers[diff.layerIndex];
    diff.changes.forEach(c => {
      const key = c.x + ',' + c.y;
      if (inverse) {
        if (c.old === null) delete L.data[key]; else L.data[key] = c.old;
      } else {
        if (c.new === null) delete L.data[key]; else L.data[key] = c.new;
      }
    });
    buildLayersUI();
    draw();
  }

  Array.from(document.querySelectorAll('.tools button')).forEach(b => {
    b.onclick = () => {
      currentTool = b.dataset.tool;
      document.querySelectorAll('.tools button').forEach(x => x.style.fontWeight = 'normal');
      b.style.fontWeight = '600';
    }
  });
  /*document.getElementById('addLayer').onclick = () => {
    layers.push({name: 'Layer ' + (layers.length + 1), opacity: 1, data: {}});
    activeLayer = layers.length - 1;
    buildLayersUI();
    draw();
  };*/

  document.getElementById('undo').onclick = () => doUndo();
  document.getElementById('redo').onclick = () => doRedo();

  document.getElementById('exportLayer').onclick = () => {
    const L = layers[activeLayer];

    // ---- BUILD blockTypes ----
    const blockSet = new Set(Object.values(L.data));
    blockSet.add(0); // Ensure 0 = "null" is included
    const blockList = Array.from(blockSet).sort((a, b) => a - b);

    const blockTypes = { 0: "null" };
    let index = 1;
    blockList.forEach(id => {
      if (id === 0) return; // skip, already 0
      blockTypes[index] = String(id); // Replace with proper name if you have one
      index++;
    });

    // ---- BUILD CHUNKS ----
    const chunks = {};
    const chunkSize = 64; // adjust if needed

    // Find all coordinates including empty
    let allCoords = new Set(Object.keys(L.data));
    allCoords.forEach(key => {
      const [x, y] = key.split(',').map(Number);
      const cx = Math.floor(x / chunkSize);
      const cy = Math.floor(y / chunkSize);
      const ckey = `${cx},${cy}`;

      if (!chunks[ckey]) chunks[ckey] = {};
      chunks[ckey][key] = L.data[key] ?? 0; // fill empty with 0
    });

    for (const ckey in chunks) {
      const [cx, cy] = ckey.split(',').map(Number);

      for (let localY = 0; localY < chunkSize; localY++) {
        for (let localX = 0; localX < chunkSize; localX++) {
          const x = cx * chunkSize + localX;
          const y = cy * chunkSize + localY;
          const key = `${x},${y}`;

          if (!(key in chunks[ckey])) {
            chunks[ckey][key] = "null"; // explicitly mark missing as null
          }
        }
      }
    }


      // ---- CONVERT RAW CHUNK DATA → RLE FORMAT ----
    for (const ckey in chunks) {
      const raw = chunks[ckey];

      // Sort by y then x
      const sorted = Object.entries(raw).sort((a, b) => {
        const [ax, ay] = a[0].split(',').map(Number);
        const [bx, by] = b[0].split(',').map(Number);
        return ay - by || ax - bx;
      });

      const toLocalId = id => blockList.indexOf(id) + 1; // +1 because 0 is "null"

      const data = [];
      let last = null;
      let count = 0;

      for (const [, value] of sorted) {
        const localId = toLocalId(value);

        if (localId !== last) {
          if (count > 0) data.push([last, count]);
          last = localId;
          count = 1;
        } else {
          count++;
        }
      }
      if (count > 0) data.push([last, count]);

      chunks[ckey] = { data };
    }

    const obj = { blockTypes, chunks };
    downloadJSON(obj, L.name + '.json');
  };



  /*document.getElementById('importLayer').onclick = () => {
    document.getElementById('fileImportLayer').click();
  }*/;
  document.getElementById('fileImportLayer').addEventListener('change', e => {
    const f = e.target.files[0];
    if (!f) return;
    const r = new FileReader();
    r.onload = () => {
      try {
        const obj = JSON.parse(r.result);
        layers.push({name: obj.name || 'Imported', opacity: 1, data: obj.data || {}});
        buildLayersUI();
        draw();
      } catch (err) {
        alert('Invalid layer JSON');
      }
    };
    r.readAsText(f);
  });

  document.getElementById('importScheme').onclick = () => {
    document.getElementById('fileSchemeJson').click();
  };
  document.getElementById('fileSchemeJson').addEventListener('change', async e => {
    const f = e.target.files[0];
    if (!f) return;
    const text = await f.text();
    let scheme = null;
    try {
      scheme = JSON.parse(text);
    } catch (err) {
      alert('Invalid scheme JSON');
      return;
    }
    const imageFiles = Array.from(document.getElementById('fileSchemeImages').files || []);
    const map = {};
    await Promise.all(imageFiles.map(async ff => { map[ff.name] = await readFileAsDataURL(ff); }));
    for (const [key, val] of Object.entries(scheme)) {
      if (val && typeof val === 'string' && val.startsWith('data:')) {
        blockScheme[key] = {id: key, name: key, url: val};
      } else if (val && typeof val === 'string' && map[val]) {
        blockScheme[key] = {id: key, name: key, url: map[val]};
      } else {
        blockScheme[key] = {id: key, name: key, url: null};
      }
    }
    buildBlockSelector();
    alert('Block scheme loaded');
  });

  function readFileAsDataURL(file) {
    return new Promise((res, rej) => {
      const r = new FileReader();
      r.onload = () => res(r.result);
      r.onerror = () => rej(r.error);
      r.readAsDataURL(file);
    });
  }

  function gatherProject() {
    return {
      title: document.getElementById('title').value,
      layers: layers,
      activeLayer: activeLayer,
      blocksUsed: gatherBlocksUsed(),
      blockScheme: blockScheme
    };
  }

  function gatherBlocksUsed() {
    const used = new Set();
    layers.forEach(L => Object.values(L.data).forEach(bid => used.add(bid)));
    return Array.from(used);
  }

  function downloadJSON(obj, name) {
    const txt = JSON.stringify(obj, null, 2);
    const blob = new Blob([txt], {type: 'application/json'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = name;
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  }

  function saveProject() {
    const p = gatherProject();
    const name = (document.getElementById('title').value || 'project') + '.wproj';
    downloadJSON(p, name);
    filename = name;
    document.getElementById('fileInfo').textContent = name;
  }

  document.getElementById('save').onclick = saveProject;
  document.getElementById('importProject').onclick = () => document.getElementById('fileOpenProject').click();

  document.getElementById('fileOpenProject').addEventListener('change', e => {
    const f = e.target.files[0];
    if (!f) return;
    const r = new FileReader();
    r.onload = () => {
      try {
        const obj = JSON.parse(r.result);
        loadProject(obj);
      } catch (err) {
        alert('Invalid project file');
      }
    };
    r.readAsText(f);
  });

  function loadProject(obj) {
    document.getElementById('title').value = obj.title || 'Untitled';
    layers = obj.layers || [];
    layers.forEach(L => { if (L.opacity === undefined) L.opacity = 1; });
    activeLayer = Math.max(0, Math.min(layers.length - 1, obj.activeLayer || 0));
    blockScheme = obj.blockScheme || blockScheme
    buildLayersUI();
    buildBlockSelector();
    draw();
    document.getElementById('fileInfo').textContent = obj.__filename || '';
  }

  document.getElementById('fileInfo').addEventListener('click', () => document.getElementById('fileOpenProject').click());

  window.addEventListener('keydown', e => {
    if (e.ctrlKey && e.key === 's') {
      e.preventDefault();
      saveProject();
    }
    if (e.ctrlKey && e.key === 'z') {
      e.preventDefault();
      doUndo();
    }
    if (e.ctrlKey && (e.key === 'y' || (e.shiftKey && e.key === 'Z'))) {
      e.preventDefault();
      doRedo();
    }
  });

  createDefaultProject();

</script>
</body>
</html>